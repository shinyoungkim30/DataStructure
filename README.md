# DataStructure

## 자료구조

## 시간복잡도
- 빅 오 표기법(big-O notation): 자료구조, 알고리즘 성능을 표시하기 위함
  > 빅오(Big-O), 빅세타(big-Θ), 빅오메가(big-Ω)

- 예시
  > [1, 2, 3, 4, 5] 배열이 있습니다. <br>
  > '3번째 숫자'를 찾을 경우 => 작업량 1 <br>
  > '숫자 4'를 찾을 경우 => 왼쪽에서부터 1234 작업량 4 <br>
  > 지금은 12345가 순서대로 있지만 4가 맨 앞에 있을 경우 작업량 1 / 맨 마지막에 있을 경우 작업량 5 <br>
  > 어떤 자료구조에 데이터가 얼마나 있을지 모르기 때문에 데이터의 총 개수를 n으로 표시하면 <br>
  > 어떤 값을 찾는 작업량을 n으로 표시할 수 있다. <br>
  > 데이터가 n개인 배열에서 특정 자리를 찾는 것은 1, 특정 값을 찾는 것은 n

- 빅오(Big-O)는 최악의 경우, 빅오메가(big-Ω)는 최선의 경우, 빅세타(big-Θ)는 최악과 최선이 같을 때

- 최악의 경우 작업량이 엄청나게 늘어나는 경우가 있기 때문에 보통 최악의 경우를 잘 고려해야 한다

- 대략 O(1), O(log n), O(n), O(nlog n), O(n^2), O(n^3), O(n^n), O(n!)의 순서대로 알고리즘이 점점 비효율적이 된다.

- 최악의 경우(Big-O)는 최선의 알고리즘을 사용했음에도 최악인 경우를 말한다.

- 업다운 게임 예시
  > 1부터 100중에 49를 찾는다고 가정합니다 <br>
  > 50 다운, 25 업, 37 업, 43 업, 46 업, 48 업, 49 => 총 7번 <br>
  > 이렇게 절반씩 줄여가면서 찾을 경우 => O(log n) <br>
  > 만약 1부터48까지, 50부터100까지 다 부르고 마지막에 49를 찾을 경우 => O(n) <br>

- for문 예시 <br>
  > for (let i = 0; i < arr.length; i++)에서 0부터 배열의 길이까지 반복하므로 => O(n) <br>
  > 이중 for문에서는 => O(n^2), 반복문이 3번있으면 O(n^3) ... <br>
  > for (let i = 0; i < arr.length; **i * 2**)에서 i가 배로 늘어나면 보통 O(log n) <br>
  > 이중 for문에서 순차적으로 늘어나는 것과 배로 늘어나는 것이 있으면 O(nlog n) <br>

- n이 큰 수일 때, 예를 들면 100만일 때, n과 2n은 별 차이가 안나지만 n과 n^2은 엄청난 차이가 난다.
- 이 지수는 **반복문의 중첩 횟수**와 관련이 있기 때문에 중첩 횟수를 잘 따져봐야 한다.

## 공간복잡도
- 자원(메모리)을 얼마나 차지하는 지를 나타내는 것
- 요즘은 메모리나 하드디스크 등의 용량이 많이 늘어났기 때문에 대부분의 경우 어느정도 허용을 해준다.

## 자료구조를 배워야 하는 이유
- 자료구조에서 삽입, 수정, 삭제를 빅 오 표기법으로 시간복잡도 표시 가능
- 만약 내 서비스가 삽입 작업이 많고 수정, 삭제를 거의 하지 않는다면 서비스에 맞춰서 자료구조를 적용할 수 있다.
- 서비스 효율 성능을 크게 높일 수 있다

## 연결리스트
- 지금 우리가 쓰는 배열은 예전에 불편했던 C의 배열에서 기능을 추가해 메모리 관리를 스스로 할 필요 없게 개선된 배열
- 이런 배열은 자료구조를 배울 때 도움이 되지 않는다! 배열이 없다면 어떻게 할까 에서 출발
<br/>
- [1, 2, 3, 4, 5] 이런 배열을 메모리라고 생각해본다(실제로는 이렇지 않지만 2차원 배열이라고 생각) <br/>
<img src="https://github.com/shinyoungkim30/DataStructure/assets/130364428/6cbaaf1f-c710-4b56-bbc1-7b1d1ef12f4f"/> <br/>
배열 자체의 메모리는 A1이고, 각 칸이 가리키는 메모리도 다 별개로 저장이 되어 있을 수 있다.<br/>
<img src="https://github.com/shinyoungkim30/DataStructure/assets/130364428/001a7af8-5b3e-46c8-b76b-2c590fd9d10f"/> <br/>
다음 데이터를 G1에 추가하고 다음 데이터를 추가할 때 A2에 추가하게 되지만 <br/>
만약 A2에 객체가 있어서 그 값들이 다음 칸까지 이미 다 차버린 경우 다음에 비어있는 칸인 E2에 추가하게 된다 <br/>
<img src="https://github.com/shinyoungkim30/DataStructure/assets/130364428/3bb20c05-89a7-443c-99d3-ff44fec5085d" /> <br/>
- 컴퓨터는 실제로 배열을 보고 데이터를 찾는게 아니라 메모리를 보고 찾게 된다
그래서 7을 찾을 때 어디에 있는지 알 수 없게 된다
- 그래서 실제로는 다음 칸에 어떤 데이터가 있는지 힌트를 저장한다(값, 다음 값) <br/>
<img src="https://github.com/shinyoungkim30/DataStructure/assets/130364428/45b25c8d-1070-4595-bace-ddbecaad11ae"/><br/>
이런식으로 A1이라는 배열은 쭉 이어지게 된다. 이렇게 체인처럼 서로서로 연결되어 있는 것을 연결리스트라고 한다 <br/>

